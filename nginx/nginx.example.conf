# nginx consistent-hash routing for kbcorego multi-pod deployments.
#
# routes requests to a stable backend pod based on the X-KB-ID header.
# this gives each kbID pod affinity for cache locality -- the same pod
# handles the same KB, reducing duplicate snapshot downloads and lease
# contention across pods.
#
# requirements:
#   - nginx compiled with ngx_http_upstream_hash_module (included by default)
#   - clients must set the X-KB-ID header on every request
#   - backend pods listed in the upstream block (or resolved via k8s headless service)
#
# kubernetes deployment:
#   - mount this file via ConfigMap into the nginx container at /etc/nginx/nginx.conf
#
#   example k8s pod spec snippet:
#     containers:
#       - name: nginx
#         image: nginx:1.27-alpine
#         volumeMounts:
#           - name: nginx-config
#             mountPath: /etc/nginx/nginx.conf
#             subPath: nginx.conf
#     volumes:
#       - name: nginx-config
#         configMap:
#           name: kbcorego-nginx
#
#   example ConfigMap creation:
#     kubectl create configmap kbcorego-nginx --from-file=nginx.conf=deploy/nginx/nginx.conf

worker_processes auto;

events {
    worker_connections 1024;
}

http {
    # ----------------------------------------------------------------
    # upstream: kbcorego pods
    #
    # option 1 (static): list pod addresses explicitly.
    # option 2 (k8s):    use a headless service DNS name with resolver.
    #
    # the `hash` directive selects a backend based on the X-KB-ID header
    # value. `consistent` enables ketama consistent hashing so that when
    # a pod is added or removed, only ~1/N of keys are remapped instead
    # of reshuffling everything.
    # ----------------------------------------------------------------
    upstream kbcorego {
        hash $kb_id consistent;

        # static pod list -- replace with actual addresses.
        # when using k8s headless service, replace these with a single
        # `server kbcorego-headless.default.svc.cluster.local:8080 resolve;`
        # and uncomment the resolver directive below.
        server 127.0.0.1:8081;
        server 127.0.0.1:8082;
        server 127.0.0.1:8083;
    }

    # uncomment for k8s headless service DNS resolution.
    # the valid=10s controls how often nginx re-resolves the DNS record
    # to pick up pod scale changes.
    #
    # resolver kube-dns.kube-system.svc.cluster.local valid=10s;

    # extract the kb id from the X-KB-ID header.
    # falls back to "default" so requests without the header still route
    # deterministically (all to the same pod) rather than failing.
    map $http_x_kb_id $kb_id {
        default   "default";
        "~.+"     $http_x_kb_id;
    }

    log_format kb_route '$remote_addr - $request - kb_id=$kb_id -> $upstream_addr';

    server {
        listen 80;
        server_name _;

        access_log /var/log/nginx/access.log kb_route;

        # health check endpoint -- not kb-specific, any pod can respond.
        location = /healthz {
            proxy_pass http://kbcorego;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # metrics and admin endpoints -- not kb-specific.
        location /metrics/ {
            proxy_pass http://kbcorego;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        location = /cache/sweep {
            proxy_pass http://kbcorego;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # kb-specific endpoints -- routed by consistent hash on X-KB-ID.
        location /rag/ {
            proxy_pass http://kbcorego;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-KB-ID $kb_id;

            # bump timeouts for large ingestion payloads.
            proxy_read_timeout 120s;
            proxy_send_timeout 120s;
            client_max_body_size 64m;
        }

        # catch-all for any future kb-routed endpoints.
        location / {
            proxy_pass http://kbcorego;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-KB-ID $kb_id;
        }
    }
}

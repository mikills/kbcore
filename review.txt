================================================================================
CODE REVIEW — MongoManifestStore + main.go wiring
================================================================================

OVERALL ASSESSMENT
------------------
The diff adds a MongoDB-backed ManifestStore with clean environment-variable
wiring. The HeadVersion projection is a nice optimisation. However there is a
correctness bug in UpsertIfMatch that can cause silent data loss under
concurrent first writes, and a few quality issues in the wiring and tests.

================================================================================
ISSUES
================================================================================

1. UpsertIfMatch("") BREAKS CAS FOR THE FIRST-WRITE RACE — CORRECTNESS BUG
----------------------------------------------------------------------------
File: kb/manifest_store_mongo.go (UpsertIfMatch)

When expectedVersion == "", the implementation does an unconditional
ReplaceOne with SetUpsert(true), which silently overwrites any existing
document. The BlobManifestStore counterpart returns ErrBlobVersionMismatch if
the blob already exists when expectedVersion == "".

If two concurrent writers both call HeadVersion and get "" (no manifest yet),
the Mongo path lets the second writer silently clobber the first. The blob
path correctly rejects the second writer.

Current code:
    if expectedVersion == "" {
        // Unconditional upsert.
        _, err := s.Collection.ReplaceOne(ctx, bson.M{"_id": kbID}, doc,
            options.Replace().SetUpsert(true),
        )
        ...
        return newVersion, nil
    }

Fix: use InsertOne for the create case and map mongo.IsDuplicateKeyError to
ErrBlobVersionMismatch:

    if expectedVersion == "" {
        _, err := s.Collection.InsertOne(ctx, doc)
        if err != nil {
            if mongo.IsDuplicateKeyError(err) {
                return "", ErrBlobVersionMismatch
            }
            return "", err
        }
        return newVersion, nil
    }

--------------------------------------------------------------------------------

2. Mongo Ping IN main.go USES context.Background() — NO TIMEOUT
---------------------------------------------------------------
File: main.go

If MongoDB is unreachable the server will hang indefinitely at startup.

Current code:
    ctx := context.Background()
    if err := mongoClient.Ping(ctx, nil); err != nil {

Fix: use a timeout context:
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := mongoClient.Ping(ctx, nil); err != nil {

--------------------------------------------------------------------------------

3. mongoClient IS NEVER DISCONNECTED — CONNECTION LEAK
------------------------------------------------------
File: main.go

mongo.Connect creates a client that is never closed. There is no
defer mongoClient.Disconnect(...) or shutdown hook. On graceful process exit
this leaks the connection pool.

Either wire a shutdown hook or defer a disconnect call alongside the client
creation.

--------------------------------------------------------------------------------

4. UNUSED json STRUCT TAGS ON mongoManifestDoc
----------------------------------------------
File: kb/manifest_store_mongo.go

    type mongoManifestDoc struct {
        ID        string                `json:"_id" bson:"_id"`
        Version   string                `json:"version" bson:"version"`
        Manifest  SnapshotShardManifest `json:"manifest" bson:"manifest"`
        UpdatedAt time.Time             `json:"updated_at" bson:"updated_at"`
    }

This struct is only ever serialised to/from BSON. The json tags are dead code
— remove them.

--------------------------------------------------------------------------------

5. TEST CASES ARE FULLY DUPLICATED FROM TestBlobManifestStore
-------------------------------------------------------------
File: kb/manifest_store_mongo_test.go

TestMongoManifestStore contains 8 subtests that are identical to those in
manifest_store_test.go. Both implement the same ManifestStore interface.

Fix: extract a shared suite function:
    func runManifestStoreTests(t *testing.T, store ManifestStore) { ... }

Both TestBlobManifestStore and TestMongoManifestStore then just call it with
their respective store instance.

================================================================================
WHAT'S GOOD
================================================================================

- HeadVersion projection: bson.M{"version": 1} avoids deserialising the full
  manifest body. Exactly right.

- CAS path for non-empty expectedVersion: ReplaceOne with
  bson.M{"_id": kbID, "version": expectedVersion} and MatchedCount == 0 check
  is correct.

- _id is the kbID: uses Mongo's primary index naturally; no secondary index
  needed for any of the queries.

- Delete on a non-existent document returns nil: DeleteOne returns nil error
  when no document matches, so the "absent is not an error" contract is
  satisfied for free.

- KBCORE_MANIFEST_MONGO_URI empty check: no Mongo dependency is pulled in
  unless explicitly configured; the blob-backed default remains untouched.

- Test isolation: each subtest gets its own collection, and t.Cleanup drops it
  and disconnects. Clean.

================================================================================
